### 2023 年 05/28(月)

## 取り組んだ課題

スッキリわかる SQL 入門

テーブル設計途中まで

## わかったこと

### 外部キーと参照整合性

外部キーが指し示す先にあるべき行が存在してリレーションシップが成立して

いることを参照整合性という！

### 参照整合性の崩壊(違反)

外部キーで紐づいている ID が存在しない状態のことを言う

この様な状態になることは避けなければならない

原因

- 他の行から参照されている行を削除
- 他の行から参照されている行の主キーを削除
- 存在しない行を参照する行を追加してしまう
- 存在しない行を参照する行に更新してしまう

## インデックスの作成と削除

索引情報はインデックスと呼ばれる！

インデックスの特徴

- インデックスは、指定した列にたいして作られる
- インデックスが存在する列に対して検索が行われると DBMS は

自動的にインデックスの使用を試みるため、高速になる場合が多い！

- インデックスには名前をつけること！

インデックス作成基本構文

`CREATE INDEX インデックス名 ON テーブル名(カラム名)`

因みにインデックス名は**重複しない範囲で任意の名前**をつけることができる！

この名前は、`DROP INDEX`文でインデックス削除する時に使う！

インデックス削除基本構文

`DROP INDEX インデックス名 ON テーブル名`

複数の列を 1 つのインデックスとする複合インデックスも作成可能！

---

### 効果を得られやすい典型的な 3 つのケース

### WHERE 句による絞り込み

そのカラムに対してサーチ機能があったとしたらインデックスつけた方がいい

### ORDER BY による並び替え

インデックスには並び替えを高速化する効果もある！！

### JOIN による結合の条件

### インデックス設定の効果が得られやすいカラム

- WHERE 句にに頻繁に登場するカラム
- ORDER BY 句に頻繁に登場するカラム
- JOIN による結合条件に頻繁に登場するカラム(外部キーカラム)

### インデックスの注意点

### インデックスは乱用しない

やたら無闇にインデックスつけるのは NG!

検索性能は向上するが、書き換え時のオーバーヘッドは増加する。

### インデックス作成することによるデメリット

- 索引情報を保存するために、ディスク容量を消費する
- テーブルのデータが変更されるとインデックスも書き換える必要があるため

INSERT 分、UPDATE 文、DELETE 文のオーバーヘッドが増える

**簡単にいうとテーブルデータが変更されるとインデックスも書き換えなければならない。**

EXPLAIN PLAN 文を使ってインデックスによって処理がどれくらい早くなるか目安を確認することができる！

---

### ACID 特性

- 原子性: 処理が中断しても中途半端な状態にならない(ロールバック)
- 一貫性: データの内容が矛盾した状態にならない(参照整合性)
- 分離性: 複数の処理を同時実行しても副作用がない(ロック)
- 永続性: 記録した情報は消滅せずに保持され続ける(バックアップから復元後ログからロールフォワード)

## 次やること

スッキリわかる SQL 入門続き

おわったらスッキリ SQL の本を読ませていただいた感想(図が多くて読むのが嫌にならなかったから読みやすい本でした)

達人に学ぶ DB 設計　徹底指南書

## 感じたこと

インデックスの概念と正規化、正規形のやり方がモヤモヤしていましたが

読み終わった今、少しだけはっきりした気がします！！！

---

お子さんがいて平日仕事している方で勉強している方本当に尊敬します！

朝の３時間しかできなかったです。

やっぱ朝はいいのかもしれません

休みの日はうるさいし定期的に部屋来るしで集中できない w(しょうがないんですけどね！)

その分平日でガチる！

お疲れ様でした！

## 勉強時間

Today: 3h

Total: 322h
