### 2023 年 06/28(水)

## 勉強したこと

Rails と Next.js の連携、API の作成と叩き方

docker-compose での開発環境構築

## わかったこと

API を叩く時、docker 同士で別コンテナにアクセスするには localhost ではなく、コンテナ名を指定する必要がある!

front と back で分けて開発は今回が初めてだから無駄に苦戦したけど、これからはそんなミスなくバンバン API 叩けるようになる！

要するに自分は Next.js のコンテナの中で Rails のコンテナを叩きたいのに Next の API を叩いていた、無いのに叩いていたということだった。

動的ルーティングの API を叩く時は、`getStaticPaths`で`fallback: true`にすると、`getStaticProps`の中で`params`を受け取れる。

初めて訪れるページは表示されるのが遅くて 404 になってしまうが少し待てば表示される。

これは、ISR(Incremental Static Regeneration)という機能で

初めて訪れた時にはサーバー側で HTML を生成して、それをキャッシュしておくことで

次回以降はキャッシュから HTML を取得することで表示を早くすることができる。

404 だからと焦らないこと！UI 向上のためにもその場合はローディングを表示するなどの工夫が必要だと思いました！

SSG と SSR の違いは、SSG はビルド時に HTML を生成するのに対して、SSR はリクエストがあるたびに HTML を生成する。

---

SSG は**ビルド時**に HTML を生成し API を叩いてデータを取得するので、

新たに API を叩くことができない。(CUD 操作ができない。R はできる)

どういうことかと言うと、すでに準備してある HTML をクライアントに返すことしかできないので CURD の読み取りはできるが、書き込みはできない。

まとめると動的にページを生成することができないが、ビルド時に生成した HTML を返すのでものすごく高速に表示できる。

SSG が向いている画面は、document やホーム画面やプロフィールなどの更新頻度が低い画面がいい！

自分のオリプロで言うと home 画面やログイン画面などがいいかもしれない。

---

SSR はリクエストがあるたびに HTML を生成するので、新たに API を叩くことができる。

どう言うことかというと、リクエストがあるたびにサーバー側で HTML を生成するので CURD 操作ができる

サーバー側で HTML を生成するので、初回表示が遅いが、2 回目以降は高速に表示できる。

```
CSR(クライアント側で HTML 生成。 react や HTML、JS)

との以外はクライアントで HTML を生成するか

サーバーで HTML を生成するかの違い。
```

ユーザーの PC スペックに左右されないので、ユーザーの PC スペックが低い人でも高速に表示できるのがメリットだが

サーバー側で HTML を生成するのでサーバーの負荷が高くなるのがデメリット。

まとめると、動的にページを生成することができるため更新頻度が高い画面に向いているが、SSG と違い初回表示が遅い。

---

ISR は SSG と SSR のいいとこ取りをした機能!

若干更新頻度が高い場合、SSG だと更新が反映されないので SSR にしたいが、SSR だと初回表示が遅いので SSG にしたいという場合に使う。

説明が難しいのですが、`getStaticProps`の中で`revalidate`を指定することで SSG から ISR を有効にすることができる。

`revalidate`には秒数を指定することができ、指定した秒数ごとにサーバー側で HTML を生成することができる。

例えば、`revalidate: 60`と指定すると 60 秒ごとに`revalidate: 60 * 60 * 24`で 24 時間なので

１日ごとにサーバー側で HTML を生成することができる。自由自在に設定できるので、更新頻度に合わせて設定することができる！

開発者ツールのコンソールで[Fast Refresh] revalidating と表示されていると

これは ISR 正常に動いていることが確認できる。

どんな画面に向いているのかというと投稿画面やコメント画面などの画面に向いている。

自分のオリプロで言うとレシピ投稿画面や原価登録画面や編集画面などがいいかもしれない。

唯一のデメリットは ISR は Vercel でしか使えない機能なので、Vercel でデプロイする必要がある。

### どうゆう時に ISR が発火するのか？

勘違いポイント: `revalidate`に指定した秒数ごとに発火するのではなく、ユーザーが ISR が有効なページにアクセスした時に発火する。

例えば、画面の更新があり`revalidate: 60`と指定して、一番最初のユーザーが来ることで 60 秒後に ISR が発火する。

よって 1 番最初のユーザーは変化に気づきにくいがそれ以降は更新されている画面になるので

2 番目以降のユーザーは更新されている状態になる！

---

このように画面によって SSG と SSR と ISR を使い分けることで、ユーザーにとって最適な UX を提供することができる！

考えることは多いが、パフォーマンス向上のためには必要なことなので、頑張っていきたい！

基本的に更新頻度が高い画面は ISR で、更新頻度が低い画面は SSG で作るのがいいと思う！

## 次やること

AWS ECS の学習

rails と next.js でできれば rails の課題をやるそこで API の叩き方の理解を深める

## 感じたこと

難しい！分からない事しかない

Next.js は初めて触ったので、まだまだ分からないことだらけだが、できることが多いし

パフォーマンスや SEO 対策にも優れているのでこれをできるようになったら最高だと思う！

焦りは禁物だが焦ってしまうのでエラーがなかなか解決できないとおでこが広がりそうになる。

## 勉強時間

Today: 12h

Total: 556h
